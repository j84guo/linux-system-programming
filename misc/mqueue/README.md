- P producers C consumers
- N integers generated by producers
- each producer generates a set of integers at a time (sequential?)
- do not want to have to co-ordinate producer actions
    * each producer has an id (0 to P - 1)
    * i % P == id
    * each integer is placed into a fixed size B buffer, shared with consumers
    * producers pause when buffer full until there is more space
- consumers have cid (0 to C - 1)
    * each consumer reads an integer out and calculates its square root
    * when the root is an integer print cid, integer, root
    * when the buffer is empty but more data is expected, consumers pause and
      wait for more integers
- mutual exclusion on buffer for producers and consumers
- terminate when all integers processed

-> how does a consumer know it read the last integer
-> do producers also have this problem or is their situation simpler  

- ./produce N B P C
- print time taken by producer

1. Implement each task as a process. Use mqueue as the bounded buffer. The
   main process forks multiple producers and consumers. At some point producers
   must stop generating messages and the consumer must consume them, else the
   kernel's memory will be saturated with messages. Therefore, setup a correct
   queue size, at which point send blocks.

2. Create a process with a fixed buffer (e.g. circular queue) in which tasks
   are threads. Shared memory access should be synchronized using semaphore and
   mutex. 

